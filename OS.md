# 操作系统

## 1.进程管理

### 1.进程与线程

- 进程和线程有什么区别？
  - 进程是**系统进行资源分配和调度的基本单位**，线程是**CPU调度和分派的基本单位**
  - 线程依赖于进程存在，一个进程至少拥有一个线程
  - 进程拥有自己的独立地址空间，线程共享所属进程的地址空间
  - 进程切换开销远大于线程
  - 线程之间通信比进程之间方便

- 进程间的通信（IPC）有哪些方式？
  - 1.**匿名管道通信**（半双工：所以双方通信需要两个管道）
  - 2.**高级管道通信**
  - 3.**有名管道通信**（允许没有亲缘关系的进程之间进行通信）
  - 4.**消息队列通信**
  - 5.**信号量通信**——用于实现进程间的互斥与同步，而不是用于存储进程间的通信数据
  - 6.**信号**
  - 7.**共享存储**：两个或多个进程共享一个给定的内存区，特点：最快，通常与信号量共同使用
  - 8.**套接字通信**
  
- 线程间的通信方式
  - 锁机制
  - 信号量
  - 信号
- 线程的实现方式有哪些？
  - 用户级线程
  - 内核级线程

- 进程有哪些状态？
  - 创建态
  - 就绪态
  - 运行态
  - 阻塞态（等待态）
  - 结束态

- 阻塞态和就绪态的区别
  - 就绪态：进程获得了除了处理机以外的一切资源，一旦处理机空闲，就可以运行
  - 阻塞态：有除了处理机以外的一些资源还需要等待

- 同一进程中的线程可以共享哪些数据？
  - 进程代码段
  - 进程的公有数据（全局变量、静态变量。。。）
  - 进程打开的文件描述符
  - 进程的当前目录
  - 信号处理器、信号的处理函数：对收到的信号的处理方式
  - 进程ID和进程组ID

- 线程独占哪些资源？
  - 线程ID
  - 一组寄存器的值
  - 线程自身的栈（堆是共享的）
  - 错误返回码
  - 信号掩码、信号屏蔽字

- 线程优先级怎么评价？
  - https://www.cnblogs.com/perfumeBear/p/12326695.html

- 进程上下文有哪些部分？

  - 所谓的进程上下文，就是一个进程在执行的时候，CPU的所有寄存器中的值、进程的状态以及堆栈上的内容，当内核需要切换到另一个进程时，它 需要保存当前进程的所有状态，即保存当前进程的进程上下文，以便再次执行该进程时，能够恢复切换时的状态，继续执行

  - 一个进程的上下文可以分为三个部分:**用户级上下文**、**寄存器上下文**以及**系统级上下文**

    - **用户级上下文**: 正文、数据、**用户堆栈**以及共享存储区

    - **寄存器上下文**: **通用寄存器**、(IP)、**处理器状态寄存器**(EFLAGS)、栈指针(ESP)

    - **系统级上下文**: **进程控制块**task_struct、**内存管理信息**(mm_struct、vm_area_struct、pgd、pte)、**内核栈**

      当发生进程调度时，进行进程切换就是上下文切换(context switch)

- 进程切换和线程切换的区别？
  - https://www.cnblogs.com/lfri/p/12597297.html

- 内核态和用户态的区别？

  - **内核态与用户态：**

  （1）**当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于内核运行态（内核态）。**此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。

  （2）**当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）**。此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。

- I/O多路复用
  - https://my.oschina.net/yinjihuan/blog/4390277

### 2.处理机调度

- 进程调度的策略/算法有哪些？

  - 批处理系统
    - 先来先服务（FCFS）
    - 最短作业优先（SJF）
    - 最短剩余时间优先（SRTN）
    - 最高响应比优先（HRRN）

  - 交互式系统
    - 时间片轮转
    - **优先级调度算法**：非剥夺式/剥夺式 静态/动态 **具体实现？？**
    - 多级反馈队列调度算法

### 3.进程同步

- 什么是进程同步？
  
- 用来协调进程之间的互相制约关系
  
- 什么是僵尸进程？

  - 我们知道在unix/linux中，正常情况下，子进程是通过父进程创建的，子进程在创建新的进程。子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程 到底什么时候结束。 当一个 进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。

  - 一个子进程结束后，它的父进程并没有等待它（调用wait或者waitpid），那么这个子进程将成为一个僵尸进程。僵尸进程是一个已经死亡的进程，但是并没有真正被销毁。它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程表中保留一个位置，记载该进程的进程ID、终止状态以及资源利用信息(CPU时间，内存使用量等等)供父进程收集，除此之外，僵尸进程不再占有任何内存空间。这个僵尸进程可能会一直留在系统中直到系统重启。

    危害：占用进程号，而系统所能使用的进程号是有限的；占用内存。

    以下情况不会产生僵尸进程：

    - 该进程的父进程先结束了。每个进程结束的时候，系统都会扫描是否存在子进程，如果有则用Init进程接管，成为该进程的父进程，并且会调用wait等待其结束。
    - 父进程调用wait或者waitpid等待子进程结束（需要每隔一段时间查询子进程是否结束）。wait系统调用会使父进程暂停执行，直到它的一个子进程结束为止。waitpid则可以加入`WNOHANG`(wait-no-hang)选项，如果没有发现结束的子进程，就会立即返回，不会将调用waitpid的进程阻塞。同时，waitpid还可以选择是等待任一子进程（同wait），还是等待指定pid的子进程，还是等待同一进程组下的任一子进程，还是等待组ID等于pid的任一子进程；
    - 子进程结束时，系统会产生`SIGCHLD`(signal-child)信号，可以注册一个信号处理函数，在该函数中调用waitpid，等待所有结束的子进程（注意：一般都需要循环调用waitpid，因为在信号处理函数开始执行之前，可能已经有多个子进程结束了，而信号处理函数只执行一次，所以要循环调用将所有结束的子进程回收）；
    - 也可以用`signal(SIGCLD, SIG_IGN)`(signal-ignore)通知内核，表示忽略`SIGCHLD`信号，那么子进程结束后，内核会进行回收。

- 什么是孤儿进程？
  
- 一个父进程已经结束了，但是它的子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程会被Init（进程ID为1）接管，当这些孤儿进程结束时由Init完成状态收集工作
  
- 线程同步有哪些方式？

  - 为什么需要？
    - 为什么需要线程同步：线程有时候会和其他线程共享一些资源，比如内存、数据库等。当多个线程同时读写同一份共享资源的时候，可能会发生冲突。因此需要线程的同步，多个线程按顺序访问资源

  - **互斥量** Mutex：互斥量是内核对象，只有拥有互斥对象的线程才有访问互斥资源的权限。因为互斥对象只有一个，所以可以保证互斥资源不会被多个线程同时访问；当前拥有互斥对象的线程处理完任务后必须将互斥对象交出，以便其他线程访问该资源
  - **信号量** Semaphore：信号量是内核对象，它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。信号量对象保存了**最大资源计数**和**当前可用资源计数**，每增加一个线程对共享资源的访问，当前可用资源计数就减1，只要当前可用资源计数大于0，就可以发出信号量信号，如果为0，则将线程放入一个队列中等待。线程处理完共享资源后，应在离开的同时通过`ReleaseSemaphore`函数将当前可用资源数加1。如果信号量的取值只能为0或1，那么信号量就成为了互斥量
  - **事件** Event：允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。事件分为手动重置事件和自动重置事件。手动重置事件被设置为激发状态后，会唤醒所有等待的线程，而且一直保持为激发状态，直到程序重新把它设置为未激发状态。自动重置事件被设置为激发状态后，会唤醒**一个**等待中的线程，然后自动恢复为未激发状态
  - **临界区** Critical Section：任意时刻只允许一个线程对临界资源进行访问。拥有临界区对象的线程可以访问该临界资源，其它试图访问该资源的线程将被挂起，直到临界区对象被释放

- 互斥量和临界区的区别？
  
- 互斥量是可以命名的，可以用于不同进程之间的同步；而临界区只能用于同一进程中线程的同步。创建互斥量需要的资源更多，因此临界区的优势是速度快，节省资源
  
- **为什么要分用户态和内核态？**
  
  - **安全性：防止用户程序恶意或者不小心破坏系统/内存/硬件资源；**
  - **封装性：用户程序不需要实现更加底层的代码；**
- 利于调度：如果多个用户程序都在等待键盘输入，这时就需要进行调度；统一交给操作系统调度更加方便
  
- 如何从用户态切换到内核态？
  - 系统调用：比如读取命令行输入。本质上还是通过中断实现
  - 用户程序发生异常时：比如缺页异常
  - 外围设备的中断：外围设备完成用户请求的操作之后，会向CPU发出中断信号，这时CPU会转去处理对应的中断处理程序

### 4.死锁

- 什么是死锁？
  
- 在两个或者多个并发进程中，每个进程持有某种资源而又等待其它进程释放它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁(deadlock)
  
- 死锁产生的必要条件？
  - **互斥**：一个资源一次只能被一个进程使用；
  - **占有并等待**：一个进程至少占有一个资源，并在等待另一个被其它进程占用的资源；
  - **非抢占**：已经分配给一个进程的资源不能被强制性抢占，只能由进程完成任务之后自愿释放；
  - **循环等待**：若干进程之间形成一种头尾相接的环形等待资源关系，该环路中的每个进程都在等待下一个进程所占有的资源

- 死锁有哪些处理方法？

  - 鸵鸟策略
    
- 直接忽略死锁。因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略
    
- 死锁预防
  
  基本思想是破坏形成死锁的四个必要条件：
  
  - 破坏互斥条件：允许某些资源同时被多个进程访问。但是有些资源本身并不具有这种属性，因此这种方案实用性**有限**
  
  - 破坏占有并等待条件：
  
    - 实行资源预先分配策略（当一个进程开始运行之前，必须**一次性**向系统申请它所需要的全部资源，否则不运行）
  
      - 或者只允许进程在没有占用资源的时候才能申请资源（申请资源前先释放占有的资源）
    - 缺点：很多时候无法预知一个进程所需的全部资源；同时，会降低资源利用率，降低系统的并发性
  
  - 破坏非抢占条件：允许进程强行抢占被其它进程占有的资源。会降低系统性能
  
  - 破坏循环等待条件：对所有资源统一编号，所有进程对资源的请求必须按照序号递增的顺序提出，即只有占有了编号较小的资源才能申请编号较大的资源。这样避免了占有大号资源的进程去申请小号资源
  
  - 死锁避免
  
  - 银行家算法
    
- 死锁检测
    
  - 如何检测死锁：检测有向图是否存在环；或者使用类似死锁避免的检测算法
    
  - 死锁解除
    - 利用抢占：挂起某些进程，并抢占它的资源。但应防止某些进程被长时间挂起而处于饥饿状态
    - 利用回滚：让某些进程回退到足以解除死锁的地步，进程回退时自愿释放资源。要求系统保持进程的历史信息，设置还原点
    - 利用杀死进程：强制杀死某些进程直到死锁解除为止，可以按照优先级进行

### 5.Java多线程

- 线程池的7个参数
  - corePollSize：核心线程数。在创建了线程池后，线程中没有任何线程，等到有任务到来时才创建线程去执行任务。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中
  - maximumPoolSize：最大线程数。表明线程中最多能够创建的线程数量
  - keepAliveTime：空闲的线程保留的时间
  - TimeUnit：空闲线程的保留时间单位
  - BlockingQueue<Runnable>：阻塞队列，存储等待执行的任务。参数有ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue可选
  - ThreadFactory：线程工厂，用来创建线程
  - RejectedExecutionHandler：队列已满，而且任务量大于最大线程的异常处理策略。有以下取值
    1. ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 
    2. ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 
    3. ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
    4. ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务

- volatile的作用？
  - https://www.cnblogs.com/xuwc/p/13794503.html

## 2. 内存管理

### 内存管理

- 分页和分段有什么区别

  - 页式存储：用户空间划分为大小相等的部分称为页（page），内存空间划分为同样大小的区域称为页框，分配时以页为单位，按进程需要的页数分配，逻辑上相邻的页物理上不一定相邻；
  - 段式存储：用户进程地址空间按照自身逻辑关系划分为若干个段（segment）（如代码段，数据段，堆栈段），内存空间被动态划分为长度不同的区域，分配时以段为单位，每段在内存中占据连续空间，各段可以不相邻；
  - 段页式存储：用户进程先按段划分，段内再按页划分，内存划分和分配按页。

  区别：

  - 目的不同：分页的目的是管理内存，用于虚拟内存以获得更大的地址空间；分段的目的是满足用户的需要，使程序和数据可以被划分为逻辑上独立的地址空间；
  - 大小不同：段的大小不固定，由其所完成的功能决定；页的大小固定，由系统决定；
  - 地址空间维度不同：分段是二维地址空间（段号+段内偏移），分页是一维地址空间（每个进程一个页表/多级页表，通过一个逻辑地址就能找到对应的物理地址）；
  - 分段便于信息的保护和共享；分页的共享收到限制；
  - 碎片：分段没有内碎片，但会产生外碎片；分页没有外碎片，但会产生内碎片（一个页填不满）

### 2.虚拟内存

- 什么是虚拟内存？

  - 每个程序都拥有自己的地址空间，这个地址空间被分成大小相等的页，这些页被映射到物理内存；但不需要所有的页都在物理内存中，当程序引用到不在物理内存中的页时，由操作系统将缺失的部分装入物理内存。这样，对于程序来说，逻辑上似乎有很大的内存空间，只是实际上有一部分是存储在磁盘上，因此叫做虚拟内存

  - 虚拟内存的优点是让程序可以获得更多的可用内存

- 如何进行地址空间到物理内存的映射？
  
- **内存管理单元**（MMU）管理着逻辑地址和物理地址的转换，其中的页表（Page table）存储着页（逻辑地址）和页框（物理内存空间）的映射表，页表中还包含包含有效位（是在内存还是磁盘）、访问位（是否被访问过）、修改位（内存中是否被修改过）、保护位（只读还是可读写）。逻辑地址：页号+页内地址（偏移）；每个进程一个页表，放在内存，页表起始地址在PCB/寄存器中
  
- 有哪些页面置换算法？

  在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中**调出**一个页面到磁盘中来腾出空间。页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。

  - **最佳页面置换算法**OPT（Optimal replacement algorithm）：置换以后不需要或者最远的将来才需要的页面，是一种理论上的算法，是最优策略
  - **先进先出**FIFO：置换在内存中驻留时间最长的页面。缺点：有可能将那些经常被访问的页面也被换出，从而使缺页率升高
  - **第二次机会算法**SCR：按FIFO选择某一页面，若其访问位为1，给第二次机会，并将访问位置0；
  - **时钟算法** Clock：SCR中需要将页面在链表中移动（第二次机会的时候要将这个页面从链表头移到链表尾），时钟算法使用环形链表，再使用一个指针指向最老的页面，避免了移动页面的开销
  - **最近未使用算法**NRU（Not Recently Used）：检查访问位R、修改位M，优先置换R=M=0，其次是（R=0, M=1）
  - **最近最少使用算法**LRU（Least Recently Used）：置换出未使用时间最长的一页；实现方式：维护时间戳，或者维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的
  - **最不经常使用算法**NFU：置换出访问次数最少的页面

- 局部性原理
  - 时间上：最近被访问的页在不久的将来还会被访问
  - 空间上：内存中被访问的页周围的页也很可能被访问

- 什么是颠簸现象？

  颠簸本质上是指频繁的页调度行为。进程发生缺页中断时必须置换某一页。然而，其他所有的页都在使用，它置换一个页，但又立刻再次需要这个页。因此会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸。内存颠簸的解决策略包括：

  - 修改页面置换算法
  - 降低同时运行的程序的数量
  - 终止该进程或增加物理内存容量

## 3.文件管理

### 磁盘管理

- 磁盘调度

  过程：磁头（找到对应的盘面）；磁道（一个盘面上的同心圆环，寻道时间）；扇区（旋转时间）。为减小寻道时间的调度算法：

  - 先来先服务
  - 最短寻道时间优先
  - 电梯算法：电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向

## 4.Linux

### 安全

- kali Linux

### 环境搭建

- 操作系统本身也是一种软件

### 基本目录操作

- 一切皆文件

### 常用的命令

- **df**：命令参数功能:检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间， 目前还剩下多少空间等信息

- **du**：命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空 间的查看，还是和df命令有一些区别的，这里介绍Linux du命令

  > 区别：df会把已经删除的文件的空间也算上

- **ps**: 使用ps指令即可查看当前系统中正在执行的进程的各种进程信息

- **kill**: kill PID 杀死进程

- **pstree**: 查看进程树

- **nm**: 查看符号表

- **netstat -nlp | grep 80**: 查看端口号为80的进程信息

- **lsof**: 列出当前系统打开文件

  
