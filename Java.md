# Java基础

## 1.JVM

### 栈

- 在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配

- 当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用

- 先进后出，后进先出

- 喝多了吐就是栈，吃多了拉就是堆

- 栈：栈内存，主管程序的运行、生命周期和线程同步；

- 线程结束，栈内存也就是释放，对于栈来说，不存在垃圾回收的问题

  一旦线程结束，栈就Over！

- 栈：8大基本类型+对象引用+实例的方法
- 栈运行原理：栈帧

### 堆

- 堆内存用来存放由**new**创建的**对象和数组**
- 在堆中分配的内存，由Java虚拟机的**自动垃圾回收器**来管理
- 在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量；引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象
- 一个JVM只有一个堆内存
- 堆内存细分为三个区域：
  - 新生区（伊甸园区）
  - 养老区
  - 永久区（JDK8以后改为元空间）

- GC垃圾回收，主要是在伊甸园区和养老区

### 堆内存调优

#### 新生区

- 类诞生和成长的地方，甚至死亡
- 伊甸园区，所有的对象都是在伊甸园区new出来的
- 幸存者区（0， 1）
- 真理：经过研究 99%的对象都是临时对象

#### 老年区

#### 永久区

这个区域是常驻内存的。用来存放一些jdk自身携带的Class对象，Interface元数据，存储的是Java运行时的一些环境或类信息~这个区域不存在垃圾回收！关闭虚拟机就会释放这个区域的内存！

一个启动类，加载了大量的第三方jar包。tomcat部署了太多的应用，大量动态生成的反射类，不断地被加载。直到内存满，就会出现OOM

- jdk1.6之前：永久代，常量池是在方法区
- jdk1.7：永久代，但是慢慢地退化了，去永久代，常量池在堆中
- jdk1.8之后：无永久代，常量池在元空间

### JPofiler：

- 元空间：逻辑上存在，物理上不存在
- 在一个项目中，突然出现了OOM故障，那么该如何排除？研究为什么出错~
  - 能够看到代码第几行出错：内存快照分析工具，MAT，Jprofiler
  - Dubug分析，一行行分析代码！

- MAT，Jprofiler作用：
  - 分析Dump内存文件，快速定位内存泄漏；
  - 获得堆中的数据
  - 获得大的对象！
  - ...

### GC

- 作用区域：方法区+堆
- JVM在进行GC时，并不是对这三个区域统一回收，大部分时候，回收都是新生代~
  - 伊甸园区
  - 幸存区（from to）
  - 老年区

GC两种类型：轻GC（普通的GC），重GC（全局GC）

题目：

- JVM的内存模型和分区~详细到每个分区放什么？
- 堆里面的分区？Eden from to old
- GC的算法有哪些？标记清除法，标记压缩，复制算法，引用计数法，怎么用的
- 轻GC和重GC分别在什么时候发生？

#### 引用计数法

- 计数本身也会消耗内存
- 用的比较少！

#### 复制算法

- 幸存区 from to 谁空谁是to
- 每次GC都会将Eden活的对象移动到幸存区中：一旦Eden区被GC后，就会是空的，to区也是空的！
- 当一个对象经历了（默认）15次GC还没有死，那么它就会进入养老区
  - -XX:MaxTenuringThreshold=5
  - 通过这个参数可以设定进入老年代的时间

- 优点：
  - 没有内存的碎片~

- 坏处：
  - 浪费了内存空间~：多了一半的空间永远是空的to，假设对象100%存货（极端情况）

**复制算法最佳使用场景：对象存活度较低的场景！！！**

#### 标记清除算法

- 扫描这些对象：对对象进行标记
- 清除：对没有标记的对象进行清除
- 优点：不需要额外的空间！
- 缺点：两次扫描，严重浪费时间，会产生内存碎片。

#### 标记压缩

- 再优化：防止内存碎片产生，再次扫描，向一端移动存活的对象，但是多了一个移动成本

- 所以经常称为标记压缩清除算法

- 或者：先标记清除几次，再压缩

#### 总结

- 内存效率：复制算法>标记清除法>标记压缩算法（时间复杂度）
- 内存整齐度：复制算法=标记压缩法>标记清除法
- 内存利用率：标记压缩=标记清除法>复制法

- 有没有最优的？没有！
- 分代收集算法
  - 年轻代：存活率低！复制算法
  - 老年代：标记清除（内存碎片不是太多）+标记压缩混合 实现

### JMM：Java Memory Model

- 什么是JMM？
  -  Java内存模型
- 它是做什么的？
  - 作用：缓存一致性协议（MESI），用于定义数据读写的规则（遵守）
  - JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储主内存中，每个线程都有一个私有的本地内存，是从主内存拷贝的
  - 解决共享对象可见性这个问题：
    - volilate

## 2.集合框架

### 队列

#### 阻塞队列

- 有哪些API?

  - add(E): 添加元素，会抛出异常

  - ~~offer~~(E): 添加元素，会抛出异常

  - **put**(E): 添加元素，当队列满的时候，进入阻塞等待状态，一直等待，直到可以添加到队列中为止

  - *offer*(E, long, TimeUnit): 添加元素 

    参数说明：

    e：将要被添加到队列中的元素

    time：long类型的。预设定的需要等待的时间

    unit：TimeUnit.超时时间的单位

  - **take**(E): 删除元素。当队列不为空的时候，返回被移除的元素；当队列为空的时候，进入阻塞等待状态
  - *poll*(long, TimeUnit): 删除元素。当队列为空的时候，进入阻塞等待，等到超时时间的时候，返回null.退出等待
  - remove(Object): 删除元素。当队列不为空的时候，调用该方法，返回被移除的元素；当队列为空的时候在调用该方法，会抛出异常
  - contains(Object)
  - remainingCapacity()

### HashMap

- 重写hashcode()和equals()的作用？
  - https://www.cnblogs.com/javastack/p/13223865.html

- HashMap的扩容机制？

### String

- String a = "123"; String b = "123"; a==b的结果是什么？
  - https://blog.csdn.net/qq_40722827/article/details/103239999

### LinkedList和ArrayList

- 区别和使用场景？
  - https://blog.csdn.net/qq_42889294/article/details/101146363

- 对比

  - 由上面的常用方法可以发现

    1.ArrayList使用数组存储元素，因此在查询时速度较快，直接返回该位置的元素即可，时间复杂度为O(1);而LinkedList使用双向链表存储元素，在查询时需要从头或者尾遍历至查询元素，时间复杂度为O(n/2);

    2.还是因为存储方式的问题，ArrayList在插入或者删除时，需要移动插入位置之后的所有元素，因此速度较慢，时间复杂度为O(n)。而LinkedList只需要找到该位置，移动”指针”即可,时间复杂度为O(1)。

  - 扩容ArrayList比较慢！而LinkedList不需要扩容！

## 3.设计模式

### 概述

- 设计模式是前辈们对代码开发经验的总结，是解决特定问题的一系列套路。它不是语法规定，而**是一套用来提高代码的可复用性、可维护性、可读性、稳健性以及安全性的解决方案**

- 设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解

- 分类

  - 创建型模式：（5）
    - 单例模式
    - 工厂模式
    - 抽象工厂模式
    - 建造者模式
    - 原型模式

  - 结构型模式：（7）
    - 适配器模式
    - 桥接模式
    - 装饰模式
    - 组合模式
    - 外观模式
    - 享元模式
    - 代理模式

  - 行为型模式：（11）
    - 模板方法模式
    - 命令模式
    - 迭代器模式
    - 观察者模式
    - 中介者模式
    - 备忘录模式
    - 解释器模式
    - 状态模式
    - 策略模式
    - 职责链模式
    - 访问者模式

### OOP七大原则

- 开闭原则：对扩展开放，对修改关闭
- 里氏替换原则：继承必须确保超类所拥有的性质在子类中仍然成立
- 依赖倒置原则：要面向接口编程，不要面向实现编程
- 单一职责原则：控制类的粒度大小、将对象解耦、提高其内聚性
- 接口隔离原则：要为各个类建立它们需要的专用接口
- 迪米特法则：只与你的直接朋友交谈，不跟陌生人说话
- 合成复用原则：尽量先使用组合或者聚合关系等关联关系来实现，其次才考虑使用继承关系来实现

### 单例模式

- https://www.zhihu.com/search?type=content&q=%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F
- 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象
- **主要解决：**一个全局使用的类频繁地创建与销毁
- **关键代码：**构造函数是私有的

### 工厂模式

- 定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行
- 主要解决接口选择的问题
- **关键代码：**创建过程在其子类执行

### 代理模式：

- **意图：**为其他对象提供一种代理以控制对这个对象的访问

### 策略模式

- 定义：定义一组算法，将每个算法都封装起来，并且使他们之间可以互换
- 讲解：https://juejin.cn/post/6844903748788027400

## 4.Java基础知识

- Java和Python的区别？
  - python是全动态性的，可以在运行时自己修改自己的代码，java只能通过变通方法实现。python的变量是动态的，而java的变量是静态的，需要事先声明，所以java ide的代码提示功能优于python ide。
  - python的产生几十年了，几十年前面向过程是主流，所以用python有好多程序用的是面向过程设计方法，很多概念从c语言过来的，class在python中是后加入的，而java是为了实现没有指针的c++（当年com组件用的引用记数，java用的虚拟机），主要采用面向对象的设计方法，很多概念是oop的概念。面向过程，相对简洁直观，但容易设计出面条程序，面向对象，相对抽象优雅，但容易过度抽象。
  - java主要用于商业逻辑强的领域，如商城系统，erp，oa,金融，保险等传统数据库事务领域，通过类似ssh框架事务代码，对商业数据库，如oralce,db2,sql server等支持较好，软件工程理念较强，适合软件工程式的多人开发模式。python主要用于web数据分析，科学计算，金融分析，信号分析，图像算法，数学计算，统计分析，算法建模，服务器运维，自动化操作，快速开发理念强，适合快速开发团队或个人敏捷模式。

- 动态语言和静态语言的区别？

  - 静态类型语言 如果在编译时知道变量的类型，则该语言是静态类型的。我们经常说道的Java、C、C++在写代码的时候必须指定每个变量的类型。 优点就是编译器可以执行各种检查，也就是程序还没跑起来就能找到一些小错误，也就是是在compile-time 检查出错误的

  - 动态类型语言 一般是脚本语言，比如说Perl、Ruby、Python、PHP、JavaScript，可以更快地编写代码，不必每次都指定类型，做type checking是在run-time的时候去做的。优点是可能代码开发快，但是维护难（但是脚本语言平常写的代码量应该不太多，还比较好debug和修改）

- java三大特性

  - 继承：继承是一种联结类的层次模型，并且允许和支持类的重用，它提供了一种明确表述共性的方法

    - java的类是单继承，即一个子类只能直接继承一个父类，而一个父类可以有多个子类；但是接口支持多继承
    - 静态方法的调用只和**变量声明的类型**相关；这个和非静态方法的重写之后的效果完全不同！

  - 封装：把过程和数据包围起来，对数据的访问只能通过指定的方式

  - 多态：多态性是指允许不同类的对象对同一消息作出响应

    - 一个对象的实现类型虽然是确定的,但是这个对象所属的类型可能有很多种

    - 注:一个对象的实际类型是确定,但是可以指向这个对象的引用的类型,却是可以是这对象实际类型的任意 父类型

    - 子类继承父类,调用a方法，如果a方法在子类中没有重写,那么就是调用的是子类继承父类的a方法, 如果重写了,那么调用的就是重写之后的方法

    - 多态的存在要有3个必要条件:要有继承，要有方法重写，父类引用指向子类对象

      补充一下第二点，既然多态存在必须要有“子类重写父类方法”这一条件，那么以下三种类型的方法是没 有办法表现出多态特性的(因为不能被重写):

      1. **static方法，因为被static修饰的方法是属于类的，而不是属于实例的**！

      2. final方法，因为被final修饰的方法无法被子类重写

      3. private方法和protected方法，前者是因为被private修饰的方法对子类不可见，后者是因为尽管被

         protected修饰的方法可以被子类见到，也可以被子类重写，但是它是无法被外部所引用的，一个 不能被外部引用的方法，怎么能谈多态呢

- 重写和重载的区别？
  - 私有方法不能被子类重写，子类继承父类后,是不能直接访问父类中的私有方法的,那么就更谈不上 重写了
  - 方法重写的时候，子类的权限修饰符必须要大于或者等于父类的权限修饰符。( private < protected < public，friendly < public )
  - 方法重写的时候，子类的返回值类型必须小于或者等于父类的返回值类型。( 子类 < 父类 ) 数据类型没有 明确的上下级关系
  - 方法重写的时候，子类的异常类型要小于或者等于父类的异常类型

- 方法绑定
  - **静态绑定:**在编译期完成，可以提高代码执行速度
  - **动态绑定:**通过对象调用的方法，采用动态绑定机制。这虽然让我们编程灵活，但是降低了代码的执行速度。这也 是JAVA比C/C++速度慢的主要因素之一。JAVA中除了final类、final方、static方法，所有方法都是JVM在 运行期才进行动态绑定的。多态:如果编译时类型和运行时类型不一致，就会造成多态

- instanceof
  - System.out.println(xinstanceofY);
     输出结果是true还是false,主要是看变量x所指向的对象实际类型是不是Y类型的"子类型"

- 类型转换

  X x = (X)o

  运行是否报错,主要是变量o所指向的对象实现类型,是不是X类型的子类型,如果不是则运行就会报错

- 总结

  - 父类引用可以指向子类对象，子类引用不能指向父类对象

  - 把子类对象直接赋给父类引用叫upcasting向上转型，向上转型不用强制转型。

    如Father father = new Son();

  - 把指向子类对象的父类引用赋给子类引用叫向下转型(downcasting)，要强制转型。

    如father就是一个指向子类对象的父类引用，把father赋给子类引用son 即Son son =(Son) father;

    其中father前面的(Son)必须添加，进行强制转换

  - upcasting **会丢失子类特有的方法**, **但是子类overriding 父类的方法，子类方法有效**
  - 向上转型的作用，减少重复代码，父类为参数，调有时用子类作为参数，就是利用了向上转型。这样 使代码变得简洁。体现了JAVA的抽象编程思想

- 静态修饰符
  - 在加载类的过程中为静态变量分配内存,实例变量在创建对象时分配内存，所以静态变量可以使用类名来 直接访问,而不需要使用对象来访问
  - 静态方法"不可以"直接访问类中的非静态变量和非静态方法,但是"可以"直接访问类中的静态变量和静态 方法 注意:this和super在类中属于非静态的变量.(静态方法中不能使用)
  - 非静态方法"可以"直接访问类中的非静态变量和非静态方法,也"可以"直接访问类中的静态变量和静态方 法
  - 父类的静态方法可以被子类继承,但是不能被子类重写
  - 父类的非静态方法不能被子类重写为静态方法 

- 匿名代码块和静态代码块
  - **注**:在构造器中给静态变量赋值,并不能保证能赋值成功,因为构造器是在创建对象的时候才指向,但是静 态变量可以不创建对象而直接使用类名来访问.

- 创建和初始化对象的过程
  1. 类加载,同时初始化类中静态的属性
  2. 执行静态代码块
  3. 分配内存空间,同时初始化非静态的属性(赋默认值,0/false/null) 
  4. 调用Student的父类构造器
  5. 对Student中的属性进行显示赋值(如果有的话)
  6. 执行匿名代码块
  7. 执行构造器
  8. 返回内存地址

- final

  - 用final修饰的类不能被继承,没有子类。 例如:我们是无法写一个类去继承String类,然后对String类型扩展的,因为API中已经被String类定义为final 的了.

  - 用final修饰的方法可以被继承,但是不能被子类的重写。 例如:每个类都是Object类的子类,继承了Object中的众多方法,在子类中可以重写toString方法、equals方 法等,但是不能重写getClass方法 wait方法等,因为这些方法都是使用fianl修饰的
  - 用final修饰的变量表示常量,只能被赋一次值.其实使用final修饰的变量也就成了常量了,因为值不会再变了

- 抽象类

  - 抽象类中可以没有抽象方法,但是有抽象方法的类一定要声明为抽象类

  - abstract修饰符可以用来修饰方法也可以修饰类,如果修饰方法,那么该方法就是抽象方法;如果修饰类,那

    么该类就是抽象类

  - 抽象类,不能使用new关键字来创建对象,它是用来让子类继承的。

    抽象方法,只有方法的声明,没有方法的实现,它是用来让子类实现的

  - 注:子类继承抽象类后,需要实现抽象类中没有实现的抽象方法,否则这个子类也要声明为抽象类

  - 接口和抽象类的区别：

    - 接口就是比“抽象类”还“抽象”的“抽象类”，可以更加规范的对子类进行约束。全面地专业地实现了: 规范和具体实现的分离
    - 抽象类还提供某些具体实现，接口不提供任何实现，接口中所有方法都是抽象方法。接口是完全面 向规范的，规定了一批类具有的公共方法规范。
    - 接口中可以不写任何方法,但如果写方法了,该方法必须是抽象方法
    - **声明类的关键字是class,声明接口的关键字是interface**
    - **注:继承的关键字是extends**，**注:实现的关键字是implements**

    - 接口中的变量都是 public static final 修饰
    - 一个类可以实现多个接口，一个接口可以继承多个父接口

## 5.JUC并发编程

### 1.什么是JUC|进程和线程

- Java Util Concurrent
- 面试高频问
- java.util java工具、包、分类
- 业务：普通的线程代码：Thread
- Runnable: 没有返回值，效率相当于Callable相对较低！

- Java默认有几个线程？
  - 两个。main, GC

- 线程：Typora，写字，自动保存（线程负责的）
- 并发，并行
  - 并发：多线程操作同一个资源
    - CPU单核，模拟出来多条线程，快速交替，是伪多核！
    - 本质：资源的充分使用！
  - 并行：多个人一起行走
- 三种开启线程的方式：Thread, Runnable, Callable

- java真的能开启线程么？
  - 不能，它只能通过native方法来调用（C++）

### 2.多线程

- 线程有几个状态？
  - 新生
  - 运行
  - 阻塞
  - 等待，死死地等
  - 超时等待
  - 终止

- wait/sleep的区别

  - 来自不同的类
    - wait: Object
    - sleep: Thread

  - 关于锁的释放
    - wait: 会释放锁
    - sleep：不会释放锁，抱着锁睡觉

  - 使用的范围是不同的
    - wait: 必须在同步代码块中
    - sleep: 可以在任何地方睡

  - 是否要捕获异常
    - wait: 不需要捕获异常
    - sleep: 需要

### 3.传统的Synchronized锁

- 线程就是一个单独的资源类，没有任何的附属操作
- 公司中的开发，降低耦合性

- synchronized解决问题举例：卖票的问题

- 本质：队列，锁

### 4.Lock

- Lock接口
  - 可重入锁
  - 公平锁：十分公平，先来后到
  - 非公平锁：可以插队（默认是，因为公平！）

### 5.Synchronized和Lock的区别

- synchronized是内置的java关键字，lock是一个java类
- synchronized无法判断获取锁的状态，lock可以判断是否获取到了锁
- **synchronized会自动释放锁，lock必须手动释放锁！如果不释放锁，死锁！**
- synchronized 线程1（获得锁，阻塞） 线程2（等待、傻傻地等）lock就不一定会等待下去
- synchronized 可重入锁，不可以中断的，非公平；lock，可重入锁，可以判断锁，非公平（可以自己设置）
- synchronized 适合锁少量的代码同步问题，lock 适合锁大量的同步代码！

### 6.生产者消费者问题

### 7.Volatile可见性和非原子性

- Volatile可以保证可见性（MESI，总线嗅探），但是不保证原子性，禁止指令重排！
