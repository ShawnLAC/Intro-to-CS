# 计算机网络

## 1.物理层

## 2.数据链路层

## 3.网络层

### 综述

- 中继系统
  - 物理层：中继器、集线器
  - 数据链路层：网桥或交换机
  - 网络层：路由器
  - 网络层以上的中继系统：网关

### 路由算法

- 路由算法有哪些
  - 静态路由算法：网络管理员手工配置
  - 动态路由算法（自适应路由算法）

- 什么是RIP（距离向量路由算法）？

  - **每个路由器维护一张表**，记录该路由器到其它网络的”跳数“，路由器到与其直接连接的网络的跳数是1，每多经过一个路由器跳数就加1；更新该表时和相邻路由器交换路由信息；路由器允许一个路径最多包含**15**个路由器，如果跳数为16，则不可达。交付数据报时优先选取距离最短的路径。

    <details open="" style="box-sizing: border-box; display: block; margin-top: 0px; margin-bottom: 16px;"><summary style="box-sizing: border-box; display: list-item; cursor: pointer;">优缺点</summary><ul style="box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 16px;"><li style="box-sizing: border-box;">实现简单，开销小</li><li style="box-sizing: border-box; margin-top: 0.25em;">随着网络规模扩大开销也会增大；</li><li style="box-sizing: border-box; margin-top: 0.25em;">最大距离为15，限制了网络的规模；</li><li style="box-sizing: border-box; margin-top: 0.25em;">当网络出现故障时，要经过较长的时间才能将此信息传递到所有路由器</li></ul></details>

### IP

- 什么是IP地址？
  - 连接到因特网上的每一台主机（或者路由器）都分配一个32比特的全球唯一标识符，即IP地址。传统的分为ABCDE五大类。
  - 组成：网络号+主机号：保证了唯一性

- 网络地址转换（NAT）的意思？（传输层）

  - **NAT是指通过将专用网络地址转换为公用地址**，从而对外隐藏内部管理的IP地址,它使得整个专用网络只需要用一个全球的IP地址就可以与因特网连通

  - 好处：**大大节省了IP地址的消耗**

- 什么是ARP（地址解析协议）？
  - 无论网络层使用什么协议，在实际网络的链路上传送数据时，最终必须使用硬件地址。所以需要一种方法来**完成IP地址到MAC地址的映射**，这就是**地址解析协议**。每台主机都设有一个**ARP高速缓存**，用来存放本局域网上各主机和路由器的IP地址到MAC地址的映射表，称为**ARP表**，使用ARP来动态维护这个ARP表。



## 4.传输层

### TCP

- TCP协议的特点？

  - TCP是面向连接的协议

  - 每条TCP连接只能有两个端点，每条TCP连接只能是点对点的（一对一的）

  - TCP提供可靠的交付服务，保证传送的数据无差错、不丢失、不重复且有序

  - TCP提供全双工通信，允许通信双方的应用进程在任何时候都能发送数据，为此TCP连接的两端都设有**发送缓存和接收缓存**，用来临时存放双向通信的数据。

    - 发送缓存用来存放以下的数据：
      1. 发送应用程序传送给发送方TCP准备发送的程序
      2. TCP已发送但尚未收到确认的数据

    - 接收缓存用来暂时存放以下数据：
      1. 按序到达但尚未被接收应用程序读取的数据
      2. 不按序到达的数据

- 什么是三次握手？242

  TCP是面向连接的协议，TCP建立连接的三个步骤称为三次握手。

  ![三次握手](https://github.com/ShawnLAC/Intro-to-CS/blob/main/images/NetWork/20191129101827556_21212.png)

  - 第一次握手：Client将SYN置1，**随机**产生一个初始序列号seq发送给Server，进入**SYN_SENT**状态
  - 第二次握手：Server收到Client的SYN=1之后，知道客户端请求建立连接，将自己的SYN置1，ACK置1，产生一个acknowledge number=sequence number+1，并**随机**产生一个自己的初始序列号，发送给客户端；进入**SYN_RCVD**状态
  - 第三次握手：客户端检查acknowledge number是否为序列号+1，ACK是否为1，检查正确之后将自己的ACK置为1，产生一个acknowledge number=服务器发的序列号+1，发送给服务器；进入**ESTABLISHED**状态；服务器检查ACK为1和acknowledge number为序列号+1之后，也进入**ESTABLISHED**状态；完成三次握手，连接建立

- TCP连接可以两次握手吗？
  - 不可以。可能会出现以下情况：**已失效的连接请求报文段又传到了服务器端**
  - client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用 “三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接

- 可以采用四次握手吗？
  - 可以。但是会降低传输的效率
  - 四次握手是指：第二次握手：Server只发送ACK和acknowledge number；而Server的SYN和初始序列号在第三次握手时发送；原来协议中的第三次握手变为第四次握手。出于优化目的，四次握手中的二、三可以合并

- 第三次握手中，如果客户端的ACK未送达服务器，会怎样？
  - 由于Server没有收到ACK确认，因此会重发之前的SYN+ACK（默认重发**五次**，之后自动关闭连接），Client收到后会重新传ACK给Server
  - 如果Client向服务器发送数据，服务器会以RST包响应

- 如果已经建立了连接，但客户端出现了故障怎么办？
  
- 服务器每收到一次客户端的请求后都会重新复位一个**计时器**，时间通常是设置为**2小时**，若两小时还没有收到客户端的任何数据，服务器就会发送一个**探测报文段**，以后每隔**75秒**发送一次。若一连发送**10**个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接
  
- 初识序列号是什么？
  
- TCP连接的一方A，随机选择一个**32**位的序列号（Sequence Number）作为发送数据的初始序列号（Initial Sequence Number，ISN），比如为1000，以该序列号为原点，对要传送的数据进行编号：1001、1002...三次握手时，把这个初始序列号传送给另一方B，以便在传输数据时，B可以确认什么样的数据编号是合法的；同时在进行数据传输时，A还可以确认B收到的每一个字节，如果A收到了B的确认编号（acknowledge number）是2001，就说明编号为1001-2000的数据已经被B成功接受
  
- 什么是四次挥手？2222

  ![四次挥手](https://github.com/ShawnLAC/Intro-to-CS/blob/main/images/NetWork/20191129112652915_15481.png)

  - 第一次挥手：Client将FIN置为1，发送一个序列号seq给Server；进入**FIN_WAIT_1**状态
  - 第二次挥手：Server收到FIN之后，发送一个ACK=1，acknowledge number=收到的序列号+1；进入**CLOSE_WAIT**状态。此时客户端已经没有要发送的数据了，但仍可以接受服务器发来的数据
  - 第三次挥手：Server将FIN置1，发送一个序列号给Client；进入**LAST_ACK**状态
  - 第四次挥手：Client收到服务器的FIN后，进入**TIME_WAIT**状态；接着将ACK置1，发送一个acknowledge number=序列号+1给服务器；服务器收到后，确认acknowledge number后，变为**CLOSED**状态，不再向客户端发送数据。客户端等待2*MSL（报文段最长寿命）时间后，也进入**CLOSED**状态。完成四次挥手

- **为什么不能把二三合并**？
  
- 因为服务器收到客户端断开连接的请求时，**可能还有一些数据没有发完**，这时先回复ACK，表示接收到了断开连接的请求。等到数据发完之后再发FIN，断开服务器到客户端的数据传送
  
- 如果第二次挥手时服务器的ACK没有送达客户机，怎么办？
  
- 客户端没有收到ACK确认，会重新发送FIN请求
  
- **客户机TIME_WAIT状态的意义是什么**？
  
  - 第四次挥手时，客户端发送给服务器的ACK有可能丢失，TIME_WAIT状态就是用来重发可能丢失的ACK报文。如果Server没有收到ACK，就会重发FIN，如果Client在2*MSL的时间内收到了FIN，就会重新发送ACK并再次等待2MSL，防止Server没有收到ACK而不断重发FIN
- **MSL**(Maximum Segment Lifetime)，指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接
  
- **TCP如何实现流量控制**？
  
  - 使用**滑动窗口协议**实现流量控制。防止发送方发送速率太快，接收方缓存区不够导致溢出。接收方会维护一个接收窗口 receiver window（窗口大小单位是字节），接受窗口的大小是根据自己的资源情况动态调整的，在返回ACK时将接受窗口大小放在TCP报文中的窗口字段告知发送方。发送窗口的大小不能超过接受窗口的大小，只有当发送方发送并收到确认之后，才能将发送窗口右移
- 发送窗口的上限为接受窗口和拥塞窗口中的较小值。接受窗口表明了接收方的接收能力，拥塞窗口表明了网络的传送能力
  
- 什么是零窗口？
  
- 如果接收方没有能力接收数据，就会将接收窗口设置为0，这时发送方必须暂停发送数据，但是会启动一个持续计时器(persistence timer)，到期后发送一个大小为1字节的探测数据包，以查看接收窗口状态。如果接收方能够接收数据，就会在返回的报文中更新接收窗口大小，恢复数据传送
  
- **TCP的拥塞控制怎么实现的**？

  ![拥塞控制](https://github.com/ShawnLAC/Intro-to-CS/blob/main/images/NetWork/20191129153624025_28293.png)

  - 拥塞控制主要由四个算法组成：**慢启动（Slow Start）、拥塞避免（Congestion voidance）、快重传 （Fast Retransmit）、快恢复（Fast Recovery）**

    1. 慢启动：刚开始发送数据时，先把**拥塞窗口**（congestion window）设置为一个最大报文段MSS的数值，每收到一个新的确认报文之后，就把拥塞窗口加1个MSS。这样每经过一个传输轮次（或者说是每经过一个往返时间RTT），拥塞窗口的大小就会加倍
    2. 拥塞避免：当拥塞窗口的大小达到**慢开始门限**(slow start threshold)时，开始执行拥塞避免算法，拥塞窗口大小不再指数增加，而是线性增加，即每经过一个传输轮次只增加1MSS

    > 无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。**（这是不使用快重传的情况）**

    3. 快重传：快重传要求接收方在收到一个失序的报文段后就立即发出**重复确认**（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期
    4. 快恢复：当发送方连续收到三个重复确认时，就把慢开始门限减半，然后执行拥塞避免算法。不执行慢开始算法的原因：**因为如果网络出现拥塞的话就不会收到好几个重复的确认**，**所以发送方认为现在网络可能没有出现拥塞**。也有的快重传是把开始时的拥塞窗口cwnd值再增大一点，即等于 ssthresh + 3*MSS 。这样做的理由是：既然发送方收到三个重复的确认，就表明有三个分组已经离开了网络。这三个分组不再消耗网络的资源而是停留在接收方的缓存中。可见现在网络中减少了三个分组。因此可以适当把拥塞窗口扩大些

- TCP和UDP的区别
  1. TCP是面向连接的，UDP是无连接（发送数据之前不需要建立连接）的
  2. TCP是可靠的，UDP不可靠（UDP接收方收到报文后，不需要给出任何确认）
  3. TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多
  4. TCP是面向字节流的，UDP是面向报文的（面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完）
  5. TCP有拥塞控制机制，UDP没有。网络出现的拥塞不会使源主机的发送速率降低，这对某些实时应用是很重要的，比如媒体通信，游戏
  6. TCP首部开销（20字节）比UDP首部开销（8字节）要大
  7. UDP 的主机不需要维持复杂的连接状态表

- 什么时候选择TCP，什么时候选择UDP？
  
- 对某些实时性要求比较高的情况，选择UDP，比如游戏，媒体通信，实时视频流（直播），即使出现传输错误也可以容忍；其它大部分情况下，HTTP都是用TCP，因为要求传输的内容可靠，不出现丢失
  
- HTTP可以使用UDP吗？
  
- HTTP不可以使用UDP，HTTP需要基于可靠的传输协议，而UDP不可靠
  
- 面向连接和无连接的区别？

  - 无连接的网络服务（数据报服务）-- 面向连接的网络服务（虚电路服务）

  - 虚电路服务：首先建立连接，所有的数据包经过相同的路径，服务质量有较好的保证

  - 数据报服务：每个数据包含目的地址，数据路由相互独立（路径可能变化）；网络尽最大努力交付数据，但不保证不丢失、不保证先后顺序、不保证在时限内交付；网络发生拥塞时，可能会将一些分组丢弃

- TCP如何保证传输的可靠性？
  1. **数据包校验**
  2. 对失序数据包重新排序（TCP报文具有序列号）
  3. 丢弃重复数据
  4. **应答机制**：接收方收到数据之后，会发送一个确认（通常延迟几分之一秒）
  5. **超时重发**：发送方发出数据之后，启动一个定时器，超时未收到接收方的确认，则重新发送这个数据
  6. **流量控制**：确保接收端能够接收发送方的数据而不会缓冲区溢出

## 5.应用层

### HTTP

- HTTP和HTTPS的区别？
  1. 端口不同：HTTP使用的是80端口，HTTPS使用443端口；
  2. HTTP（超文本传输协议）信息是明文传输，HTTPS运行在SSL(Secure Socket Layer)之上，添加了加密和认证机制，更加安全
  3. HTTPS由于加密解密会带来更大的CPU和内存开销
  4. HTTPS通信需要证书，一般需要向证书颁发机构（CA）购买

- HTTPS的连接过程是什么？

  1. 客户端向服务器发送请求，同时发送客户端支持的一套加密规则（包括对称加密、非对称加密、摘要算法）
  2. 服务器从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，**加密公钥**（用于非对称加密），以及证书的颁发机构等信息（证书中的私钥只能用于服务器端进行解密）
  3. 客户端验证服务器的合法性，包括：证书是否过期，CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配
  4. 如果证书受信任，或者用户接收了不受信任的证书，浏览器会生成一个**随机密钥**（用于对称算法），并用服务器提供的公钥加密（采用非对称算法对密钥加密）；使用Hash算法对握手消息进行**摘要**计算，并对摘要使用之前产生的密钥加密（对称算法）；将加密后的随机密钥和摘要一起发送给服务器
  5. 服务器使用自己的私钥解密，得到对称加密的密钥，用这个密钥解密出Hash摘要值，并验证握手消息是否一致；如果一致，服务器使用对称加密的密钥加密握手消息发给浏览器
  6. 浏览器解密并验证摘要，若一致，则握手结束。之后的数据传送都使用对称加密的密钥进行加密

  - 总结：非对称加密算法用于在握手过程中加密生成的密码；对称加密算法用于对真正传输的数据进行加密；HASH算法用于验证数据的完整性

- 你访问的网站是如何自动切换到HTTPS的？
  
- 一种是原始的**302跳转**，服务器把所有的HTTp流量跳转到HTTPS。但这样有一个漏洞，就是中间人可能在第一次访问站点的时候就劫持。 解决方法是引入HSTS机制，用户浏览器在访问站点的时候强制使用HTTPS
  
- 什么是对称加密？什么是非对称加密？
  - 对称加密：加密和解密采用相同的密钥。如：DES、RC2、RC4
  - 非对称加密：需要两个密钥：公钥和私钥。如果用公钥加密，需要用私钥才能解密。如：**RSA**
  - 区别：对称加密速度更快，通常用于大量数据的加密；非对称加密安全性更高（不需要传送私钥）

- 数字签名、报文摘要的原理
  - 发送者A用私钥进行签名，接收者B用公钥验证签名。因为除A外没有人有私钥，所以B相信签名是来自A。A不可抵赖，B也不能伪造报文
  - 摘要算法:MD5、SHA

- Get和Post的区别？
  1. GET是幂等的，即读取同一个资源，总是得到相同的数据，POST不是幂等的
  2. **GET一般用于从服务器获取资源，而POST有可能改变服务器上的资源**
  3. **请求形式上：GET请求的数据附在URL之后，在HTTP请求头中；POST请求的数据在请求体中**
  4. 安全性：GET请求可被缓存、收藏、保留到历史记录，且其请求数据明文出现在URL中。POST的参数不会被保存，安全性相对较高
  5. GET只允许ASCII字符，POST对数据类型没有要求，也允许二进制数据
  6. GET的长度有限制（操作系统或者浏览器），而POST数据大小无限制

- Cookie和Session的区别？

  - Session是**服务器端**保持状态的方案，Cookie是**客户端**保持状态的方案

  - Cookie保存在客户端本地，客户端请求服务器时会将Cookie一起提交；Session保存在服务端，通过检索Sessionid查看状态。保存Sessionid的方式可以采用Cookie，如果禁用了Cookie，可以使用URL重写机制（把会话ID保存在URL中）

- 从输入网址到获得页面的过程？
  1. 浏览器查询 **DNS**，**获取域名对应的IP地址**:具体过程包括**浏览器**搜索自身的**DNS缓存**、搜索操作系统的DNS缓存、读取本地的**Host文件**和向**本地DNS服务器**进行查询等。对于向本地DNS服务器进行查询，如果要查询的域名包含在**本地配置区域资源**中，则返回解析结果给客户机，完成**域名解析**(此解析具有权威性)；如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询
  2. 浏览器获得域名对应的**IP地址**以后，浏览器向服务器请求建立链接，发起**三次握手**
  3. **TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求**
  4. 服务器接收到这个请求，并根据路径参数映射到特定的**请求处理器**进行处理，并将处理结果及相应的**视图**返回给浏览器
  5. 浏览器**解析并渲染视图**，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源
  6. **浏览器根据其请求到的资源、数据渲染页面**，最终向用户呈现一个完整的页面

- HTTP有哪些常见的状态码？
  1. 100：继续
  2. **2xx状态码：请求成功。200 OK**
  3. **3xx状态码：重定向**。301 永久重定向；302暂时重定向
  4. **4xx状态码：客户端错误**。**400 Bad Request：客户端请求的语法错误**；**401 Unauthorized：请求要求客户的身份认证**；**403 Forbidden：理解请求但拒绝；404 Not Found**， 405：方法不支持
  5. **5xx状态码：服务端错误**。**500服务器内部错误**；501服务不支持请求的功能，不可用

- 说说有哪些应用层协议？
  - HTTP（80）
  - HTTPS（443）
  - SMTP（25）：邮件发送
  - DNS（53）：域名--IP地址转换（运行在UDP上）
  - FTP（21）：文件传输
  - SSH（22）：远程登录
  - TELNET（23）：远程登录
  - POP3（110）：接收邮件

- 什么是域名投毒？
  
  - 是指一些刻意制造或无意中制造出来的**域名服务器数据包**，把域名指往不正确的IP地址的过程

- 什么是Restful风格？
  - 每一个URI代表一种**资源**；客户端和服务器之间，传递这种资源的某种表现层；客户端通过四个HTTP动词，对服务器端资源进行操作，实现"**表现层状态转化**"
  - Restful风格是通过不同的HTTP动作来判断操作的类型，动作不会显示在URI上
  - Java springmvc实践：@PathVariable ，在URI里面就不需要写 a= 和 b= 了

- HTTP5个动词

  - GET（SELECT）：从服务器取出资源（一项或多项）

  - POST（CREATE）：在服务器新建一个资源
  - PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）
  - PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）
  - DELETE（DELETE）：从服务器删除资源

## 6.其他

- 七层结构
  - 物理层
  - 数据链路层
  - 网络层
  - 传输层
  - 会话层
  - 表示层
  - 应用层
