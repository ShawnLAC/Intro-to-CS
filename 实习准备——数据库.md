# 实习准备——数据库

## 1.数据库基础

### 事务

- 什么是事务？
  
- 事务（Transaction）是一个操作序列，不可分割的工作单位，以BEGIN TRANSACTION开始，以ROLLBACK/COMMIT结束
  
- 事务的特性？
  - A：原子性：逻辑上是不可分割的操作单元，事务的所有操作要么全部成功，要么全部失败回滚
  - C：一致性：事务的执行必须与数据库保持一致状态，在一致性状态下，所有事务对一个数据的读取结果都是相同的
  - I：隔离性：并发执行的事务之间不能相互影响
  - D：永久性：一旦事务提交成功，对数据的修改是永久性的

- 会出现哪些并发一致性问题？
  - 丢失修改：一个事务对数据进行了修改，在事务提交之前，另一个事务对同一个数据进行了修改，覆盖了之前的修改
  - 脏读：一个事务读取了被另一个事务修改、但未提交（进行了回滚）的数据，造成两个事务得到的数据不一致
  - 不可重复读：在同一个事务中，某查询操作在一个时间读取某一行数据和之后一个时间读取该行数据，发现数据已经发生修改（可能被更新或删除了）
  - 幻读：当同一查询多次执行时，由于其它事务在这个数据范围内执行了插入操作，会导致每次返回不同的结果集（和不可重复读的区别：针对的是一个数据整体/范围；并且需要是插入操作）

- 数据库的四种隔离级别

  - 未提交读：在一个事务提交之前，它的执行结果对其它事务也是可见的。会导致脏读、不可重复读、幻读

  - 提交读：一个事务只能看见已经提交的事务所作的改变。可避免脏读问题

  - 可重复读：可以确保同一个事务在多次读取同样的数据时得到相同的结果，（**MySQL的默认隔离级别**），可避免不可重复读

  - 可串行化：强制事务串行执行，使之不可能相互冲突，从而解决幻读问题。可能导致大量的超时现象和锁竞争，实际很少使用

    

    ![Screen Shot 2020-12-02 at 6.01.16 PM](/Users/yanxiangru/2020找实习/实习准备——数据库.assets/Screen Shot 2020-12-02 at 6.01.16 PM.png)


- MYSQL事务提交的流程？

  - **事务完整流程:**

  1.事务开始

  2.申请锁资源，对id=2这行数据上排他锁

  3.将需要修改的data pages读取到innodb_buffer_cache

  4.记录id=2的数据到undo log

  5.记录id=2修改后的数据到redo log buffer

  6.将buffer cache中id=2的name改为test

  7.commit，触发二阶段提交2pc

  8.事务结束

- redo log 和 undo log 实现了什么功能？

  - 数据库通常借助日志来实现事务，常见的有undo log、redo log，undo/redo log都能保证事务特性，这里主要是原子性和持久性，即事务相关的操作，要么全做，要么不做，并且修改的数据能得到持久化

  - 假设数据库在操作时，按如下约定记录日志：

    ```text
    1. 事务开始时，记录START T
    2. 事务修改时，记录（T，x，v），说明事务T操作对象x，x的值为v 
    3. 事务结束时，记录COMMIT T 
    ```

  - undo log是把所有没有COMMIT的事务回滚到事务开始前的状态，系统崩溃时，可能有些事务还没有COMMIT，在系统恢复时，这些没有COMMIT的事务就需要借助undo log来进行回滚

  - 使用undo log时，要求：

    ```text
    1. 记录修改日志时，(T，x，v）中v为x修改前的值，这样才能借助这条日志来回滚；
    2. 事务提交后，必须在事务的所有修改（包括记录的修改日志）都持久化后才能写COMMIT T日志；这样才能保证，宕机恢复时，已经COMMIT的事务的所有修改都已经持久化，不需要回滚。
    ```

  - 使用undo log时事务执行顺序

    ```text
    1. 记录START T 
    2. 记录需要修改的记录的旧值（要求持久化）
    3. 根据事务的需要更新数据库（要求持久化）
    4. 记录COMMIT T 
    ```

  - 使用undo log进行宕机回滚

    ```text
    1. 扫描日志，找出所有已经START,还没有COMMIT的事务。
    2. 针对所有未COMMIT的日志，根据undo log来进行回滚。 
    ```

  - redo log是指在回放日志的时候把已经COMMIT的事务重做一遍，对于没有commit的事务按照abort处理，不进行任何操作。

  - 使用redo log时，要求：

    ```text
    1. 记录redo log时，(T,x，v）中的v必须是x修改后的值，否则不能通过redo log来恢复已经COMMIT的事务。
    2. 写COMMIT T日志之前，事务的修改不能进行持久化，否则恢复时，对于未COMMIT的操作，可能有数据已经修改，但重放redo log不会对该事务做任何处理，从而不能保证事务的原子性。 
    ```

  - 使用redo log时事务执行顺序

    ```text
    1. 记录START T
    2. 记录事务需要修改记录的新值（要求持久化）
    3. 记录COMMIT T（要求持久化）
    4. 将事务相关的修改写入数据库 
    ```

  - 使用redo log重做事务

    ```text
    1. 扫描日志，找到所有已经COMMIT的事务；
    2. 对于已经COMMIT的事务，根据redo log重做事务； 
    ```

### 锁

- 什么是乐观锁和悲观锁？
  - 悲观锁：认为数据随时会被修改，因此每次读取数据之前都会上锁，防止其它事务读取或修改数据；应用于**数据更新比较频繁**的场景
  - 乐观锁：操作数据时不会上锁，但是更新时会判断在此期间有没有别的事务更新这个数据，若被更新过，则失败重试；适用于**读多写少**的场景。乐观锁的实现方式有：
    - 加一个版本号或者时间戳字段，每次数据更新时同时更新这个字段；
    - 先读取想要更新的字段或者所有字段，更新的时候比较一下，只有字段没有变化才进行更新

- 常见的锁类型？
  - **排它锁**（Exclusive Lock）/ X锁：事务对数据加上X锁时，只允许此事务读取和修改此数据，并且其它事务不能对该数据加任何锁
  - **共享锁**（Shared Lock）/ S锁：加了S锁后，该事务只能对数据进行读取而不能修改，并且其它事务只能加S锁，不能加X锁
  - **意向锁**（Intention Locks）：
    - 一个事务在获得某个**数据行**对象的 S 锁之前，必须先获得**整个表**的 IS 锁或更强的锁；
    - 一个事务在获得某个数据行对象的 X 锁之前，必须先获得**整个表**的 IX 锁；
    - IS/IX 锁之间都是兼容的；
    - 好处：如果一个事务想要对**整个表**加X锁，就需要先检测是否有其它事务对该表或者该表中的某一行加了锁，这种检测非常耗时。有了意向锁之后，只需要检测整个表是否存在IX/IS/X/S锁就行了

- 锁的作用？
  - 用于管理对共享资源的并发访问，保证数据库的完整性和一致性

- 封锁粒度的概念？
  - **行级锁**以及**表级锁**

- 封锁粒度小：
  - 好处：锁定的数据量越少，发生锁争用的可能就越小，系统的**并发程度**就越高
  - 坏处：**系统开销**大（加锁、释放锁、检查锁的状态都需要消耗资源）

- 什么是三级封锁协议？
  - 一级封锁协议：事务在修改数据之前必须先对其加X锁，直到事务结束才释放。可以解决丢失修改问题（两个事务不能同时对一个数据加X锁，避免了修改被覆盖）
  - 二级封锁协议：在一级的基础上，事务在读取数据之前必须先加S锁，**读完后释放**。可以解决脏读问题（如果已经有事务在修改数据，就意味着已经加了X锁，此时想要读取数据的事务并不能加S锁，也就无法进行读取，避免了读取脏数据）
  - 三级封锁协议：在二级的基础上，事务在读取数据之前必须先加S锁，**直到事务结束才能释放**。可以解决不可重复读问题（避免了在事务结束前其它事务对数据加X锁进行修改，保证了事务期间数据不会被其它事务更新）

- 什么是两段锁协议？
  - 事务必须严格分为两个阶段对数据进行**加锁和解锁**的操作，第一阶段加锁，第二阶段解锁。也就是说一个事务中一旦释放了锁，就不能再申请新锁了。
  - **可串行化调度**是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。事务遵循两段锁协议是保证可串行化调度的充分条件

- 什么是MVCC?

  - 多版本并发控制（Multi-Version Concurrency Control, MVCC），MVCC在每行记录后面都保存有两个隐藏的列，用来存储**创建版本号**和**删除版本号**
  - 创建版本号：创建一个数据行时的事务版本号（**事务版本号**：事务开始时的系统版本号；系统版本号：每开始一个新的事务，系统版本号就会自动递增）
  - 删除版本号：删除操作时的事务版本号
  - 各种操作：
    - 插入操作时，记录创建版本号；
    - 删除操作时，记录删除版本号；
    - 更新操作时，先记录删除版本号，再新增一行记录创建版本号；
    - 查询操作时，要符合以下条件才能被查询出来：删除版本号未定义或大于当前事务版本号（删除操作是在当前事务启动之后做的）；创建版本号小于或等于当前事务版本号（创建操作是事务完成或者在事务启动之前完成）

  - 通过版本号减少了锁的争用，**提高了系统性能**；可以实现**提交读**和**可重复读**两种隔离级别，未提交读无需使用MVCC

- 快照读与当前读？
  - 使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销
  - 当前读读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁

### 数据库基础

- 数据库的范式？
  - **第一范式**（1NF，Normal Form）：**属性不应该是可分的**。举例：如果将“电话”作为一个属性（一列），是不符合1NF的，因为电话这个属性可以分解为家庭电话和移动电话...如果将“移动电话”作为一个属性，就符合1NF；
  - 第二范式 2NF：每个非主属性完全依赖于主属性集（候选键集）；
    - B完全依赖于A，就是说A中的所有属性唯一决定B，属性少了就不能唯一决定，属性多了则有冗余（叫依赖不叫完全依赖）。举例：（学号，课程名）这个主属性集可以唯一决定成绩，但是对于学生姓名这个属性，（学号，课程名）这个属性集就是冗余的，所以学生姓名不完全依赖于（学号，课程名）这一属性集；
    - 主属性集/候选码集：某一组属性能够唯一确定其它的属性（主键就是从候选键集中选的一个键），而其子集不能，这样的属性组中的属性就是主属性；不在候选码集中的属性成为非主属性；
    - 可以通过分解来满足 2NF：将（学号，课程名，成绩）做成一张表；（学号，学生姓名）做成另一张表，避免大量的数据冗余；
  - 第三范式 3NF：在 2NF 的基础上，非主属性不传递依赖于主属性
    - 传递依赖：如果C依赖于B，B依赖于A，那么C传递依赖于A；
    - 3NF在2NF的基础上，消除了非主属性之间的依赖；比如一个表中，主属性有（学号），非主属性有（姓名，院系，院长名），可以看到院长名这个非主属性依赖于院系，传递依赖于学号。消除的办法是分解。

- 不符合范式会产生哪些异常？
  - 冗余数据：某些同样的数据多次出现（如学生姓名）
  - 修改异常：修改了一个记录中的信息，另一个记录中相同的信息却没有修改
  - 删除异常：删除一个信息，那么也会丢失其它信息（删除一个课程，丢失了一个学生的信息）
  - 插入异常：无法插入（插入一个还没有课程信息的学生）

- 什么是存储过程？有哪些优缺点？

  - 存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合。想要实现相应的功能时，只需要调用这个存储过程就行了（类似于函数，输入具有输出参数）
  - 优点：
    - 预先编译，而不需要每次运行时编译，提高了数据库执行**效率**
    - 封装了一系列操作，对于一些数据交互比较多的操作，相比于单独执行SQL语句，可以**减少网络通信量**
    - 具有**可复用性**，减少了数据库开发的工作量
    - **安全性高**，可以让没有权限的用户通过存储过程间接操作数据库
    - 更**易于维护**

  - 缺点：
    - **可移植性差**，存储过程将应用程序绑定到了数据库上；
    - **开发调试复杂**：没有好的IDE；
    - **修改复杂**，需要重新编译，有时还需要更新程序中的代码以更新调用

- ### Drop/Delete/Truncate的区别？

  - **Delete**用来删除表的全部或者**部分数据**，执行delete之后，用户**需要提交**之后才会执行，会触发表上的DELETE**触发器**（包含一个OLD的虚拟表，可以只读访问被删除的数据），DELETE之后表结构还在，删除很慢，一行一行地删，因为会记录日志，可以利用日志还原数据
  - **Truncate**删除表中的所有数据，这个操作**不能回滚**，也不会触发这个表上的触发器。操作比DELETE快很多（直接把表drop掉，再创建一个新表，删除的数据不能找回）。如果表中有自增（AUTO_INCREMENT）列，则重置为1
  - **Drop**命令从数据库中**删除表**，所有的数据行，索引和约束都会被删除；不能回滚，不会触发触发器

- 什么是触发器？
  
- 触发器（TRIGGER）是由事件（比如INSERT/UPDATE/DELETE）来触发运行的操作（不能被直接调用，不能接收参数）。在数据库里以独立的对象存储，用于**保证数据完整性**（比如可以检验或转换数据）
  
- 有哪些约束类型？
  
- 约束（Constraint）类型：主键（Primary Key）约束，唯一约束（Unique），检查约束，非空约束，外键（Foreign Key）约束
  
- 什么是视图？什么是游标？
  - 视图：从数据库的基本表中通过查询选取出来的数据组成的虚拟表（数据库中存放视图的定义）。可以对其进行增/删/改/查等操作。特别地，对视图的修改不影响基本表。好处：
    - 通过只给用户访问视图的权限，保证数据的**安全性**
    - **简化**复杂的SQL操作，隐藏数据的复杂性（比如复杂的连接）
  - 游标（Cursor）：用于定位在查询返回的**结果集的特定行**，以对特定行进行操作。使用游标可以方便地对结果集进行移动遍历，根据需要滚动或对浏览/修改任意行中的数据。主要用于交互式应用

## 2.MySQL

### 索引

- 索引的作用：提高查询的速度，但是会一定程度上影响增删改的效率

- 使用B树和B+树的比较

  InnoDB的索引使用的是B+树实现，B+树对比B树的好处：

  - IO次数少：B+树的中间结点只存放索引，数据都存在叶结点中，因此中间结点可以存更多的数据，让索引树更加矮胖
  - 范围查询效率更高：B树需要遍历整个树，只B+树需要遍历叶结点中的链表
  - 查询效率更加稳定：每次查询都需要从根结点到叶结点，路径长度相同，所以每次查询的效率都差不多

- ##### 使用B树索引和哈希索引的比较

  - 哈希索引能以 O(1) 时间进行查找，但是只支持精确查找，无法用于部分查找和范围查找，无法用于排序与分组；B树索引支持大于小于等于查找，范围查找。哈希索引遇到大量哈希值相等的情况后查找效率会降低。哈希索引不支持数据的排序

- 使用索引的优点？
  - 大大加快了数据的**检索速度**
  - 可以显著减少查询中**分组和排序**的时间
  - 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性
  - 将随机 I/O 变为**顺序 I/O**（B+Tree 索引是有序的，会将相邻的数据都存储在一起）

- 缺点？

  建立和维护索引耗费时间空间，更新索引很慢

- 哪些情况下索引会失效？
  - 以“%(表示任意0个或多个字符)”开头的LIKE语句；
  - OR语句前后没有同时使用索引；
  - 数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）；
  - 对于多列索引，必须满足 **最左匹配原则**/最左前缀原则 (最左优先，eg：多列索引col1、col2和col3，则 索引生效的情形包括 col1或col1，col2或col1，col2，col3)；
  - 如果MySQL估计全表扫描比索引快，则不使用索引（比如非常小的表）

- 在哪些地方适合创建索引？
  - 某列经常作为最大最小值；
  - 经常被查询的字段；
  - 经常用作表连接的字段；
  - 经常出现在ORDER BY/GROUP BY/DISDINCT后面的字段

- 创建索引时应该注意什么？
  - 只应建立在**小字段**上，而不要对大文本或图片建立索引（一页存储的数据越多一次IO操作获取的数据越大效率越高）
  - 建立索引的字段应该**非空**，在MySQL中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。应该用0、一个特殊的值或者一个空串代替NULL
  - 选择**数据密度大**（唯一值占总数的百分比很大）的字段作索引

- 索引的分类？
  - 普通索引
  - 唯一索引 UNIQUE：索引列的值必须唯一，但允许有空值；
  - 主键索引 PRIMARY KEY：必须唯一，不允许空值（是一种特殊的唯一索引；MySQL创建主键时默认为聚集索引，但主键也可以是非聚集索引）；
  - 单列索引和多列索引/复合索引（Composite）：索引的列数；
  - 覆盖（Covering）索引：索引包含了所有满足查询所需要的数据，查询的时候只需要读取索引而不需要回表读取数据；
  - 聚集（Clustered）索引/非聚集索引：对磁盘上存放数据的物理地址重新组织以使这些数据按照指定规则排序的一种索引（数据的物理排列顺序和索引排列顺序一致）。因此每张表只能创建一个聚集索引（因为要改变物理存储顺序）。优点是查询速度快，因为可以直接按照顺序得到需要数据的物理地址。缺点是进行修改的速度较慢。对于需要经常搜索范围的值很有效。非聚集索引只记录逻辑顺序，并不改变物理顺序；
  - 分区索引（？）
  - 虚拟索引（Virtual）：模拟索引的存在而不用真正创建一个索引，用于快速测试创建索引对执行计划的影响。没有相关的索引段，不增加存储空间的使用

- Mysql的两种存储引擎InnoDB和MyISAM的区别？
  
  - InnoDB**支持事务**，可以进行Commit和Rollback；
  - MyISAM 只支持表级锁，而 InnoDB 还**支持行级锁**，提高了并发操作的性能；
  - InnoDB **支持外键**；
  - MyISAM **崩溃**后发生损坏的概率比 InnoDB 高很多，而且**恢复的速度**也更慢；
  - MyISAM 支持**压缩**表和空间数据索引，InnoDB需要更多的内存和存储；
- InnoDB 支持在线**热备份**
  
- 应用场景
  - **MyISAM** 管理非事务表。它提供高速存储和检索（MyISAM强调的是性能，每次查询具有原子性，其执行速度比InnoDB更快），以及全文搜索能力。如果表比较小，或者是只读数据（有大量的SELECT），还是可以使用MyISAM；
  - **InnoDB** 支持事务，并发情况下有很好的性能，基本可以替代MyISAM

- 冷备份和热备份的区别
  - 热备份：在数据库运行的情况下备份的方法。优点：可按表或用户备份，备份时数据库仍可使用，可恢复至任一时间点。但是不能出错
  - 冷备份：数据库正常关闭后，将关键性文件复制到另一位置的备份方式。优点：操作简单快速，恢复简单

- MySQL一次查询的过程？
  - **发送SQL语句**：客户端与MySQL服务器建立TCP连接后发送一条SQL语句给MySQL服务器
  - **检查SQL缓存**：MySQL服务器会先检查SQL语句是不是SELECT型的，如果是，则会先去检查查询缓存，如果缓存命中，则立即返回存储在缓存中的结果；如果没有命中，则执行下一步
  - **生成执行计划**：MySQL 服务器进行 SQL 解析、预处理，最后，优化器会先预测多个执行计划的成本，然后选择生成其中成本最小的一个。优化器根据一系列的统计信息得来：每个表或者索引的页数（page）、索引的基数（即索引中不同值的数量）、索引和数据行的长度、索引分布情况等，注意优化器并没有考虑到任何缓存，它假设所有读取都是读磁盘。注意，解析和预处理的主要作用是检测 SQL语句是否有错误，而这里的执行计划是一颗“指令树”
  - **执行**：MySQL 服务器遍历这棵“指令树”，并调用相关存储引擎 API 来执行查询；存储引擎将数据返回给 MySQL 服务器后（一条一条），还有可能对返回的数据进行筛选、排序、分组等操作
  - **返回结果**：MySQL 服务器将结果返回给客户端，这是一个增量、逐步返回的过程，服务器一旦得到了一条完整的记录，就开始向客户端逐步返回结果集了。也就是说，结果集中的每一行都会以 MySQL 客户端或服务器通信协议进行封包，然后再通过 TCP协议传输。这种做法的好处是，MySQL 不需要存储太多的结果，节约了内存，同时，也能让客户端尽早地接收到结果。可以通过使用 **SQL_BUFFER_RESULT** 来改变 MySQL 的这种行为，这个 hint 告诉优化器将查询结果先放入到一个临时表中，然后尽快地释放相关的锁资源。不过，带来的坏处是 MySQL服务器将需要更多的内存

- MySQL的binlog有几种录入格式？

  - 有三种格式，statement，row和mixed。

    - statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。
    - row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。
    - mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。

    此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。

- SQL执行效率太低怎么办？

  - 可以尝试在一个字段未建立索引时，根据该字段查询的效率，然后对该字段建立索引（`alter table 表名 add index(字段名)`），同样的SQL执行的效率，你会发现查询效率会有明显的提升（数据量越大越明显）。

  - order by

    当我们使用`order by`将查询结果按照某个字段排序时，如果该字段没有建立索引，那么执行计划会将查询出的所有数据使用外部排序（将数据从硬盘分批读取到内存使用内部排序，最后合并排序结果），这个操作是很影响性能的，因为需要将查询涉及到的所有数据从磁盘中读到内存（如果单条数据过大或者数据量过多都会降低效率），更无论读到内存之后的排序了。

    但是如果我们对该字段建立索引`alter table 表名 add index(字段名)`，那么由于索引本身是有序的，因此直接按照索引的顺序和映射关系逐条取出数据即可。而且如果分页的，那么只用**取出索引表某个范围内的索引对应的数据**，而不用像上述那**取出所有数据**进行排序再返回某个范围内的数据。（从磁盘取数据是最影响性能的）

  - join

    对`join`语句匹配关系（`on`）涉及的字段建立索引能够提高效率

- 什么是最左匹配原则？
  - 顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。
  - 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
  - =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式

### 其他



## 3.其他

- MySQL和Redis的区别？
  - MySQL存储于硬盘上，Redis存储于缓存上（内存）
  - 配合使用

- Redis为什么单线程还这么快？

  - 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)

  - 数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的

  - 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗

  - 使用**多路I/O复用模型**，非阻塞IO

    - 什么是多路I/O复用？

      **这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程**

      知乎：https://www.zhihu.com/question/32163005

  - 使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求

- 如何保证用户密码安全性？
  - https://www.jianshu.com/p/5b9692c91683

